// Generated by CoffeeScript 1.12.7
// This code is generated code from client/src/annotator/anchoring/util.coffee script.

define(function(require, exports, module) {
  var $, Util, ref, simpleXPathJQuery, simpleXPathPure;

  $ = require('jquery');

  ref = require('xpath'), simpleXPathJQuery = ref.simpleXPathJQuery, simpleXPathPure = ref.simpleXPathPure;

  Util = {};

  Util.flatten = function(array) {
    var flatten;
    flatten = function(ary) {
      var el, flat, i, len;
      flat = [];
      for (i = 0, len = ary.length; i < len; i++) {
        el = ary[i];
        flat = flat.concat(el && $.isArray(el) ? flatten(el) : el);
      }
      return flat;
    };
    return flatten(array);
  };

  Util.getTextNodes = function(jq) {
    var getTextNodes;
    getTextNodes = function(node) {
      var nodes;
      if (node && node.nodeType !== Node.TEXT_NODE) {
        nodes = [];
        if (node.nodeType !== Node.COMMENT_NODE) {
          node = node.lastChild;
          while (node) {
            nodes.push(getTextNodes(node));
            node = node.previousSibling;
          }
        }
        return nodes.reverse();
      } else {
        return node;
      }
    };
    return jq.map(function() {
      return Util.flatten(getTextNodes(this));
    });
  };

  Util.getLastTextNodeUpTo = function(n) {
    var result;
    switch (n.nodeType) {
      case Node.TEXT_NODE:
        return n;
      case Node.ELEMENT_NODE:
        if (n.lastChild != null) {
          result = Util.getLastTextNodeUpTo(n.lastChild);
          if (result != null) {
            return result;
          }
        }
        break;
    }
    n = n.previousSibling;
    if (n != null) {
      return Util.getLastTextNodeUpTo(n);
    } else {
      return null;
    }
  };

  Util.getFirstTextNodeNotBefore = function(n) {
    var result;
    switch (n.nodeType) {
      case Node.TEXT_NODE:
        return n;
      case Node.ELEMENT_NODE:
        if (n.firstChild != null) {
          result = Util.getFirstTextNodeNotBefore(n.firstChild);
          if (result != null) {
            return result;
          }
        }
        break;
    }
    n = n.nextSibling;
    if (n != null) {
      return Util.getFirstTextNodeNotBefore(n);
    } else {
      return null;
    }
  };

  Util.xpathFromNode = function(el, relativeRoot) {
    var exception, result;
    try {
      result = simpleXPathJQuery.call(el, relativeRoot);
    } catch (error) {
      exception = error;
      console.log("jQuery-based XPath construction failed! Falling back to manual.");
      result = simpleXPathPure.call(el, relativeRoot);
    }
    return result;
  };

  Util.nodeFromXPath = function(xp, root) {
    var i, idx, len, name, node, ref1, step, steps;
    steps = xp.substring(1).split("/");
    node = root;
    for (i = 0, len = steps.length; i < len; i++) {
      step = steps[i];
      ref1 = step.split("["), name = ref1[0], idx = ref1[1];
      idx = idx != null ? parseInt((idx != null ? idx.split("]") : void 0)[0]) : 1;
      node = findChild(node, name.toLowerCase(), idx);
    }
    return node;
  };

  /**
   * Functions to convert between DOM ranges and characters offsets within the
   * `textContent` of HTML elements.
   *
   * Convert `start` and `end` character offset positions within the `textContent`
   * of a `root` element into a `Range`.
   *
   * Throws if the `start` or `end` offsets are outside of the range `[0,
   * root.textContent.length]`.
   *
   * @param {HTMLElement} root
   * @param {number} start - Character offset within `root.textContent`
   * @param {number} end - Character offset within `root.textContent`
   * @return {Range} Range spanning text from `start` to `end`
   */
  function toRange(root, start, end) {
    // The `filter` and `expandEntityReferences` arguments are mandatory in IE
    // although optional according to the spec.
    const nodeIter = root.ownerDocument.createNodeIterator(
        root,
        NodeFilter.SHOW_TEXT,
        null, // filter
        false // expandEntityReferences
    );

    let startContainer;
    let startOffset;
    let endContainer;
    let endOffset;

    let textLength = 0;

    let node;
    while ((node = nodeIter.nextNode()) && (!startContainer || !endContainer)) {
      const nodeText = node.nodeValue;

      if (
          !startContainer &&
          start >= textLength &&
          start <= textLength + nodeText.length
      ) {
        startContainer = node;
        startOffset = start - textLength;
      }

      if (
          !endContainer &&
          end >= textLength &&
          end <= textLength + nodeText.length
      ) {
        endContainer = node;
        endOffset = end - textLength;
      }

      textLength += nodeText.length;
    }

    if (!startContainer) {
      throw new Error('invalid start offset');
    }
    if (!endContainer) {
      throw new Error('invalid end offset');
    }

    const range = root.ownerDocument.createRange();
    range.setStart(startContainer, startOffset);
    range.setEnd(endContainer, endOffset);

    return range;
  }

  module.exports = {
    nodeFromXPath: Util.nodeFromXPath,
    xpathFromNode: Util.xpathFromNode,
    getTextNodes: Util.getTextNodes,
    getFirstTextNodeNotBefore: Util.getFirstTextNodeNotBefore,
    getLastTextNodeUpTo: Util.getLastTextNodeUpTo
  };

});
