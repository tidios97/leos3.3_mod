// Generated by CoffeeScript 1.12.7
(function() {
  var FragmentAnchor, LeosAnchor, RangeAnchor, TextPositionAnchor, TextQuoteAnchor, domAnchorTextPosition, domAnchorTextQuote, fragmentAnchor, ref;

  ref = require('./types'), RangeAnchor = ref.RangeAnchor, FragmentAnchor = ref.FragmentAnchor, TextPositionAnchor = ref.TextPositionAnchor, TextQuoteAnchor = ref.TextQuoteAnchor;

  domAnchorTextQuote = require('dom-anchor-text-quote');

  domAnchorTextPosition = require('dom-anchor-text-position');

  fragmentAnchor = require('dom-anchor-fragment');


  /**
   * Converts between TextPositionSelector selectors and Range objects.
   */

  LeosAnchor = (function() {
    var _adjustAnchorWhitespace, _getRootElement, _removeSuperfluousWhitespace;

    function LeosAnchor(root, id, exact, prefix, suffix, start, end) {
      this.id = id;
      this.root = root;
      this.exact = exact;
      this.prefix = prefix;
      this.suffix = suffix;
      this.start = start;
      this.end = end;
    }

    LeosAnchor.fromRange = function(root, range, options) {
      var domAnchorPositionSelector, domAnchorQuoteSelector, fragmentSelector, selector;
      fragmentSelector = fragmentAnchor.fromRange(root, range);
      domAnchorQuoteSelector = domAnchorTextQuote.fromRange(_getRootElement(root, fragmentSelector.id), range, options);
      domAnchorPositionSelector = domAnchorTextPosition.fromRange(_getRootElement(root, fragmentSelector.id), range, options);
      selector = new LeosAnchor(root, fragmentSelector.id, domAnchorQuoteSelector.exact, domAnchorQuoteSelector.prefix, domAnchorQuoteSelector.suffix, domAnchorPositionSelector.start, domAnchorPositionSelector.end);
      return LeosAnchor.fromSelector(root, selector);
    };

    LeosAnchor.fromSelector = function(root, selector) {
      return new LeosAnchor(root, selector.id, selector.exact, selector.prefix, selector.suffix, selector.start, selector.end);
    };

    LeosAnchor.prototype.toSelector = function() {
      return {
        type: 'LeosSelector',
        id: this.id,
        exact: this.exact,
        prefix: this.prefix,
        suffix: this.suffix,
        start: this.start,
        end: this.end
      };
    };

    LeosAnchor.prototype.toRange = function(options) {
      var dummyTextNode, error, range, ref1, rootNode, whitespaceAdjustedAnchor;
      if (options == null) {
        options = {};
      }
      try {
        options.hint = this.toSelector().start;
        rootNode = _getRootElement(this.root, this.id);
        dummyTextNode = document.createTextNode("");
        rootNode.appendChild(dummyTextNode);
        whitespaceAdjustedAnchor = _adjustAnchorWhitespace(this);
        range = domAnchorTextQuote.toRange(rootNode, this.toSelector(), options);
        if (range === null) {
          range = domAnchorTextQuote.toRange(rootNode, whitespaceAdjustedAnchor.toSelector(), options);
        }
        if (range === null) {
          range = domAnchorTextPosition.toRange(rootNode, this.toSelector(), options);
        }
        if (range === null) {
          range = domAnchorTextPosition.toRange(rootNode, whitespaceAdjustedAnchor.toSelector(), options);
        }
      } catch (error1) {
        error = error1;
        if (error.message.indexOf("Failed to execute 'setEnd' on 'Range'") !== -1) {
          if ((this.start == null) || (this.end == null) || (this.start === (ref1 = this.end) && ref1 === 0)) {
            throw new Error('Range creation failed');
          }
          this.end -= 1;
          range = domAnchorTextPosition.toRange(_getRootElement(this.root, this.id), this.toSelector(), options);
        }
      }
      if (range === null) {
        throw new Error('Range creation failed');
      }
      return range;
    };

    LeosAnchor.prototype.toPositionAnchor = function(options) {
      var anchor, positionAnchorRoot;
      if (options == null) {
        options = {};
      }
      positionAnchorRoot = _getRootElement(this.root, this.id);
      anchor = domAnchorTextQuote.toTextPosition(positionAnchorRoot, this.toSelector(), options);
      if (anchor === null) {
        throw new Error('Quote not found');
      }
      return new TextPositionAnchor(positionAnchorRoot, anchor.start, anchor.end);
    };

    _getRootElement = function(root, id) {
      if ((root == null) && (id == null)) {
        throw new Error('Element not found');
      }
      try {
        return root.querySelector('#' + id);
      } catch (error1) {
        throw new Error('Element not found');
      }
    };


    /**
     * Returns a new anchor object where superfluous whitespace
     * of @param anchor.prefix, @param anchor.exact and @param anchor.suffix
     * are removed. Additionally the @param anchor.start and @param anchor.end
     * indicees are adjusted accordingly.
     */

    _adjustAnchorWhitespace = function(anchor) {
      var adjustedAnchor, adjustedEndIndex, adjustedStartIndex, textLengthDifferenceStart, textLengthDifferenceTotal;
      if (!anchor.prefix || !anchor.exact || !anchor.suffix) {
        return anchor;
      }
      adjustedAnchor = new LeosAnchor(anchor != null ? anchor.root : void 0, anchor != null ? anchor.id : void 0, anchor.exact, anchor.prefix, anchor.suffix,
        anchor != null ? anchor.start : void 0, anchor != null ? anchor.end : void 0);
      adjustedAnchor.prefix = _removeSuperfluousWhitespace(adjustedAnchor.prefix);
      adjustedAnchor.exact = _removeSuperfluousWhitespace(adjustedAnchor.exact);
      adjustedAnchor.suffix = _removeSuperfluousWhitespace(adjustedAnchor.suffix);
      textLengthDifferenceStart = anchor.prefix.length - adjustedAnchor.prefix.length;
      textLengthDifferenceTotal = textLengthDifferenceStart;
      textLengthDifferenceTotal += anchor.exact.length - adjustedAnchor.exact.length;
      adjustedStartIndex = Math.max(0, anchor.start - textLengthDifferenceStart);
      adjustedEndIndex = Math.max(0, anchor.end - textLengthDifferenceTotal);
      adjustedAnchor.start = adjustedStartIndex;
      adjustedAnchor.end = adjustedEndIndex;
      return adjustedAnchor;
    };


    /**
     * Removes linefeeds ("\n") and replaces multiple successive space characters with a single one.
     * Note: it does not use "\s" for matching the space characters in order to preserve non-breaking spaces (char code: 160), which turned out to improve matching
     * accuracy.
     */

    _removeSuperfluousWhitespace = function(stringToClean) {
      if (!stringToClean) {
        return stringToClean;
      }
      return stringToClean.replace(/[\n ]+/g, " ");
    };

    return LeosAnchor;

  })();

  exports.LeosAnchor = LeosAnchor;
  exports.FragmentAnchor = FragmentAnchor;
  exports.RangeAnchor = RangeAnchor;
  exports.TextPositionAnchor = TextPositionAnchor;
  exports.TextQuoteAnchor = TextQuoteAnchor;
}).call(this);
